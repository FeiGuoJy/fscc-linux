#!/usr/bin/python3

"""
        Copyright (C) 2010  Commtech, Inc.

        This file is part of fscc-linux.

        fscc-linux is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        fscc-linux is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with fscc-linux.  If not, see <http://www.gnu.org/licenses/>.

"""

import random
import string
import sys
import binascii
import threading

import argparse
import fscc


def random_string(length):
    chars = []

    for i in range(length):
        chars.append(random.choice(string.ascii_letters + string.digits))

    return "".join(chars)


def write_worker(args, data):
    outgoing_data = data

    try:
        if args.hex:
            outgoing_data = binascii.b2a_hex(outgoing_data)
    except:
        pass

    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        for i in range(args.iterations):
            port.write(outgoing_data)

        port.close()


def random_write(args):
    write_worker(args, random_string(args.length).encode())


def write(args):
    write_worker(args, args.data.encode())


def read(args):
    port = fscc.Port(args.port, "rb")

    if args.append_status == 0:
        port.append_status = False
    else:
        port.append_status = True

    for i in range(args.iterations):
        incoming_data = port.read(args.length)

        if args.hex:
            incoming_data = binascii.a2b_hex(incoming_data)

        print(incoming_data)

    port.close()


def loop(args):
    """
    class WriteThread(threading.Thread):
        def __init__(self, port_name, data):
            super(WriteThread, self).__init__()

            self.port = fscc.Port(port_name, "w+")
            self.data = data

        def run(self):
            for packet in self.data:
                self.port.write(packet)

    class ReadThread(threading.Thread):
        def __init__(self, port_name, data):
            super(ReadThread, self).__init__()

            self.port = fscc.Port(port_name, "w+")
            self.data = data

        def run(self):
            failures = 0

            for i, packet in enumerate(self.data, start=1):
                if self.port.read(4096) != packet:
                    failures += 1

                print("\b" * len(str(i - 1)), end="", file=sys.stdout)
                print(str(i), end="", file=sys.stdout)
                sys.stdout.flush()

            print("\b" * len(str(len(self.data))), end="", file=sys.stdout)
            sys.stdout.flush()

            print("%i failure%s out of %i iteration%s (%2.1f%%)" % \
                  (failures, "s"[failures == 1:],
                  len(self.data), "s"[len(self.data) == 1:],
                  (float(failures)) / float(len(self.data)) * 100))

    ports = [fscc.Port(name, "w+") for name in [args.port1, args.port2]]

    for port in ports:
        port.flush_tx()
        port.flush_rx()

    outgoing_data = [random_string(random.randint(1, args.max_length)).encode() for i in range(1, args.iterations + 1)]

    threads = [ReadThread(args.port2, outgoing_data), WriteThread(args.port1, outgoing_data)]

    for thread in threads:
        #thread.daemon = True
        thread.start()
    """

    ports = [fscc.Port(name, "w+") for name in [args.port1, args.port2]]

    failures = 0

    for i in range(1, args.iterations + 1):
        outgoing_data = random_string(random.randint(1, args.max_length)).encode()
        incoming_data = ""

        if i % 2 == 0:
            ports[0].write(outgoing_data)
            incoming_data = ports[1].read(args.max_length)
        else:
            ports[1].write(outgoing_data)
            incoming_data = ports[0].read(args.max_length)

        if outgoing_data != incoming_data:
            failures = failures + 1

        if i > 1:
            print("\b" * len(str(i - 1)), end="", file=sys.stdout)

        print(str(i), end="", file=sys.stdout)
        sys.stdout.flush()

    print("\b" * len(str(args.iterations)), end="", file=sys.stdout)
    sys.stdout.flush()

    print("%i failure%s out of %i iteration%s (%2.1f%%)" % \
          (failures, "s"[failures == 1:],
          args.iterations, "s"[args.iterations == 1:],
          (float(failures)) / float(args.iterations) * 100))



def set_registers(args):
    ports = [fscc.Port(port, "wb") for port in args.port]

    import_file = open("/tmp/fscc_settings", "w+")

    for line in args.data.split("\n"):
        import_file.write("%s\n" % line)

    import_file.close()

    import_file = open("/tmp/fscc_settings", "r")

    for port in ports:
        port.registers.import_from_file(import_file)

    import_file.close()


def get_registers(args):
    port = fscc.Port(args.port, "rb")

    port.registers.export_to_file(sys.stdout)


def flush_tx(args):
    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        port.flush_tx()
        port.close()


def flush_rx(args):
    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        port.flush_rx()
        port.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Tools for using the Commtech FSCC line of cards.')
    subparsers = parser.add_subparsers()

    parser_write = subparsers.add_parser('write', description="Sends a frame of data out of an FSCC port.", help='sends a frame of data out of an FSCC port.')
    parser_write.add_argument('port', type=str, nargs='+', help='the fscc node to send data out of')
    parser_write.add_argument('data', type=str, help='the data to send out of the port')
    parser_write.add_argument('--hex', type=int, default=0, help='whether or not the data is hexidecimal')
    parser_write.add_argument('--iterations', type=int, default=1, help='how many times to transmit the data')
    parser_write.set_defaults(func=write)

    parser_random = subparsers.add_parser('random', description="Sends a frame of random data out of an FSCC port.", help='sends a frame of random data out of an FSCC port.')
    parser_random.add_argument('port', type=str, nargs='+', help='the fscc node to send data out of')
    parser_random.add_argument('--length', type=int, default=1000, help='frame length')
    parser_random.add_argument('--iterations', type=int, default=1, help='how many times to transmit the data')
    parser_random.set_defaults(func=random_write)

    parser_read = subparsers.add_parser('read', help='receives a frame of data from an FSCC port')
    parser_read.add_argument('port', type=str, help='the fscc node to receive data out of')
    parser_read.add_argument('--append_status', type=int, default=0, help='whether or not to append the status bytes to the data')
    parser_read.add_argument('--hex', type=int, default=0, help='whether or not the data is hexidecimal')
    parser_read.add_argument('--length', type=int, default=4096, help='the largest frame size in frame based mode or how much data to read in transparent')
    parser_read.add_argument('--iterations', type=int, default=1, help='how many times to read in data')
    parser_read.set_defaults(func=read)

    parser_loop = subparsers.add_parser('loop', help='sends data back and forth between FSCC ports')
    parser_loop.add_argument('port1', type=str, help='one of the nodes to loop between')
    parser_loop.add_argument('port2', type=str, help='the other node to loop between')
    parser_loop.add_argument('--iterations', type=int, default=100, help='number of iterations to send data back and forth')
    parser_loop.add_argument('--max_length', type=int, default=4090, help='maximum frame length')
    parser_loop.set_defaults(func=loop)

    parser_set_registers = subparsers.add_parser('set-registers', help='sets the register\'s values of an FSCC port')
    parser_set_registers.add_argument('port', type=str, nargs='+', help='the fscc node to have it\'s register\'s set.')
    parser_set_registers.add_argument('data', type=str, help='the register data to set')
    parser_set_registers.set_defaults(func=set_registers)

    parser_get_registers = subparsers.add_parser('get-registers', help='gets a register\'s value from an FSCC port')
    parser_get_registers.add_argument('port', type=str, help='the fscc node to get a register\'s value from')
    parser_get_registers.set_defaults(func=get_registers)

    parser_flush_tx = subparsers.add_parser('flush-tx', help='Removes all pending transmit data')
    parser_flush_tx.add_argument('port', type=str, nargs='+', help='the fscc node to remove its pending data')
    parser_flush_tx.set_defaults(func=flush_tx)

    parser_flush_rx = subparsers.add_parser('flush-rx', help='Removes all pending receive data')
    parser_flush_rx.add_argument('port', type=str, nargs='+', help='the fscc node to remove its pending data')
    parser_flush_rx.set_defaults(func=flush_rx)

    args = parser.parse_args()
    args.func(args)
