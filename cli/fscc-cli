#!/usr/bin/python

import argparse
import random
import string
import threading
import readline
import sys
import fscc


def random_write(args):
    outgoing_data = "".join([random.choice(string.letters + string.digits) for x in range(0, args.length)])

    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        port.write(outgoing_data)
        port.close()


def write(args):
    outgoing_data = args.data

    if args.type == "hex":
        outgoing_data = outgoing_data.decode("hex")
    
    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        for i in range(args.iterations):
            port.write(outgoing_data)
        	
        port.close()


def read(args):
    port = fscc.Port(args.port, "rb")
    incoming_data = port.read(4096)
    
    if args.type == "hex":
        incoming_data = incoming_data.encode("hex")
    
    print(incoming_data)

    port.close()


def loop(args):
    failures = 0

    port1 = fscc.Port(args.port1, "w+")
    port2 = fscc.Port(args.port2, "w+")

    for i in range(1, args.iterations + 1):
        outgoing_data = "".join([random.choice(string.letters + string.digits) for x in range(0, random.randint(1, args.max_length))])
        incoming_data = ""

        if i % 2 == 0:
            port1.write(outgoing_data)
            incoming_data = port2.read(args.max_length)
        else:
            port2.write(outgoing_data)
            incoming_data = port1.read(args.max_length)

        if outgoing_data != incoming_data:
            failures = failures + 1

        if i > 1:
            sys.stdout.write("\b" * len(str(i - 1)))

        sys.stdout.write(str(i))
        sys.stdout.flush()

    sys.stdout.write("\b" * len(str(args.iterations)))
    sys.stdout.flush()

    print("%i failure%s out of %i iteration%s (%2.1f%%)" % \
          (failures, "s"[failures == 1:],
          args.iterations, "s"[args.iterations == 1:],
          (float(failures)) / float(args.iterations) * 100))


def set_registers(args):
    ports = []
    
    for port in args.port:
        ports.append(fscc.Port(port, "wb"))

    reg_list = args.data.split("\n")
	
    for reg_string in reg_list:
        d = reg_string.split("=")
        reg_name, reg_val = d[0].strip().upper(), d[1].strip()

        if reg_val[0] == "0" and (reg_val[1] == "x" or reg_val[1] == "X"):
            reg_val = int(reg_val, 16)
        else:
            rev_val = int(reg_val)
            
        for port in ports:
            setattr(port, reg_name, reg_val)
            
    for port in ports:
    	port.set_registers()


def get_registers(args):
    port = fscc.Port(args.port, "rb")
            
    for reg in port.register_names:
    	setattr(port, reg, fscc.FSCC_UPDATE_VALUE)
    	
    port.get_registers()
    	
    for reg in port.register_names:
    	print("%s = 0x%08x" % (reg, getattr(port, reg)))
    	
def flush_tx(args):
    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        port.flush_tx()
        port.close()
        
def flush_rx(args):
    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        port.flush_rx()
        port.close()
        

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Tools for using the Commtech FSCC line of cards.')
    subparsers = parser.add_subparsers()

    parser_write = subparsers.add_parser('write', description="Sends a frame of data out of an FSCC port.", help='sends a frame of data out of an FSCC port.')
    parser_write.add_argument('port', type=str, nargs='+', help='the fscc node to send data out of')
    parser_write.add_argument('data', type=str, help='the data to send out of the port')
    parser_write.add_argument('--type', type=str, choices=["ascii", "hex"], default="ascii", help='the type of data to be transmitted')
    parser_write.add_argument('--iterations', type=int, default=1, help='how many times to transmit the data')
    parser_write.set_defaults(func=write)

    parser_random = subparsers.add_parser('random', description="Sends a frame of random data out of an FSCC port.", help='sends a frame of random data out of an FSCC port.')
    parser_random.add_argument('port', type=str, nargs='+', help='the fscc node to send data out of')
    parser_random.add_argument('--length', type=int, default=1000, help='frame length')
    parser_random.set_defaults(func=random_write)

    parser_read = subparsers.add_parser('read', help='receives a frame of data from an FSCC port')
    parser_read.add_argument('port', type=str, help='the fscc node to receive data out of')
    parser_read.add_argument('--type', type=str, choices=["ascii", "hex"], default="ascii", help='the type of data to be transmitted')
    parser_read.set_defaults(func=read)

    parser_loop = subparsers.add_parser('loop', help='sends data back and forth between FSCC ports')
    parser_loop.add_argument('port1', type=str, help='one of the nodes to loop between')
    parser_loop.add_argument('port2', type=str, help='the other node to loop between')
    parser_loop.add_argument('--iterations', type=int, default=100, help='number of iterations to send data back and forth')
    parser_loop.add_argument('--max_length', type=int, default=4090, help='maximum frame length')
    parser_loop.set_defaults(func=loop)

    parser_set_registers = subparsers.add_parser('set-registers', help='sets the register\'s values of an FSCC port')
    parser_set_registers.add_argument('port', type=str, nargs='+', help='the fscc node to have it\'s register\'s set.')
    parser_set_registers.add_argument('data', type=str, help='the register data to set')
    parser_set_registers.set_defaults(func=set_registers)

    parser_get_registers = subparsers.add_parser('get-registers', help='gets a register\'s value from an FSCC port')
    parser_get_registers.add_argument('port', type=str, help='the fscc node to get a register\'s value from')
    parser_get_registers.set_defaults(func=get_registers)

    parser_get_registers = subparsers.add_parser('flush_tx', help='Removes all pending transmit data')
    parser_get_registers.add_argument('port', type=str, nargs='+', help='the fscc node to remove its pending data')
    parser_get_registers.set_defaults(func=flush_tx)

    parser_get_registers = subparsers.add_parser('flush_rx', help='Removes all pending receive data')
    parser_get_registers.add_argument('port', type=str, nargs='+', help='the fscc node to remove its pending data')
    parser_get_registers.set_defaults(func=flush_rx)

    args = parser.parse_args()
    args.func(args)
