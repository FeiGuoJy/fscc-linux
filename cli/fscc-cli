#!/usr/bin/python

import random
import string
import sys

import argparse
import fscc


def random_write(args):
    outgoing_data = "".join([random.choice(string.letters + string.digits) for x in range(0, args.length)])

    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        port.write(outgoing_data)
        port.close()


def write(args):
    outgoing_data = args.data

    if args.hex:
        outgoing_data = outgoing_data.decode("hex")

    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        for i in range(args.iterations):
            port.write(outgoing_data)

        port.close()


def read(args):
    port = fscc.Port(args.port, "rb")

    if args.append_status == 0:
        port.disable_append_status()
    else:
        port.enable_append_status()

    incoming_data = port.read(4096)

    if args.hex:
        incoming_data = incoming_data.encode("hex")

    print(incoming_data)

    port.close()


def loop(args):
    failures = 0

    port1 = fscc.Port(args.port1, "w+")
    port2 = fscc.Port(args.port2, "w+")

    for i in range(1, args.iterations + 1):
        outgoing_data = "".join([random.choice(string.letters + string.digits) for x in range(0, random.randint(1, args.max_length))])
        incoming_data = ""

        if i % 2 == 0:
            port1.write(outgoing_data)
            incoming_data = port2.read(args.max_length)
        else:
            port2.write(outgoing_data)
            incoming_data = port1.read(args.max_length)

        if outgoing_data != incoming_data:
            failures = failures + 1

        if i > 1:
            sys.stdout.write("\b" * len(str(i - 1)))

        sys.stdout.write(str(i))
        sys.stdout.flush()

    sys.stdout.write("\b" * len(str(args.iterations)))
    sys.stdout.flush()

    print("%i failure%s out of %i iteration%s (%2.1f%%)" % \
          (failures, "s"[failures == 1:],
          args.iterations, "s"[args.iterations == 1:],
          (float(failures)) / float(args.iterations) * 100))


def set_registers(args):
    ports = [fscc.Port(port, "wb") for port in args.port]

    import_file = open("/tmp/fscc_settings", "w+")

    for line in args.data.split("\n"):
        import_file.write("%s\n" % line)

    import_file.close()

    import_file = open("/tmp/fscc_settings", "r")

    for port in ports:
        port.import_registers(import_file)
        port.set_registers()

    import_file.close()


def get_registers(args):
    port = fscc.Port(args.port, "rb")

    for reg in port.register_names:
        setattr(port, reg, fscc.FSCC_UPDATE_VALUE)

    port.get_registers()
    port.export_registers(sys.stdout)


def flush_tx(args):
    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        port.flush_tx()
        port.close()


def flush_rx(args):
    for port_name in args.port:
        port = fscc.Port(port_name, "wb")

        port.flush_rx()
        port.close()


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Tools for using the Commtech FSCC line of cards.')
    subparsers = parser.add_subparsers()

    parser_write = subparsers.add_parser('write', description="Sends a frame of data out of an FSCC port.", help='sends a frame of data out of an FSCC port.')
    parser_write.add_argument('port', type=str, nargs='+', help='the fscc node to send data out of')
    parser_write.add_argument('data', type=str, help='the data to send out of the port')
    parser_write.add_argument('--hex', type=int, default=0, help='whether or not the data is hexidecimal')
    parser_write.add_argument('--iterations', type=int, default=1, help='how many times to transmit the data')
    parser_write.set_defaults(func=write)

    parser_random = subparsers.add_parser('random', description="Sends a frame of random data out of an FSCC port.", help='sends a frame of random data out of an FSCC port.')
    parser_random.add_argument('port', type=str, nargs='+', help='the fscc node to send data out of')
    parser_random.add_argument('--length', type=int, default=1000, help='frame length')
    parser_random.set_defaults(func=random_write)

    parser_read = subparsers.add_parser('read', help='receives a frame of data from an FSCC port')
    parser_read.add_argument('port', type=str, help='the fscc node to receive data out of')
    parser_read.add_argument('--append_status', type=int, default=0, help='whether or not to append the status bytes to the data')
    parser_read.add_argument('--hex', type=int, default=0, help='whether or not the data is hexidecimal')
    parser_read.set_defaults(func=read)

    parser_loop = subparsers.add_parser('loop', help='sends data back and forth between FSCC ports')
    parser_loop.add_argument('port1', type=str, help='one of the nodes to loop between')
    parser_loop.add_argument('port2', type=str, help='the other node to loop between')
    parser_loop.add_argument('--iterations', type=int, default=100, help='number of iterations to send data back and forth')
    parser_loop.add_argument('--max_length', type=int, default=4090, help='maximum frame length')
    parser_loop.set_defaults(func=loop)

    parser_set_registers = subparsers.add_parser('set-registers', help='sets the register\'s values of an FSCC port')
    parser_set_registers.add_argument('port', type=str, nargs='+', help='the fscc node to have it\'s register\'s set.')
    parser_set_registers.add_argument('data', type=str, help='the register data to set')
    parser_set_registers.set_defaults(func=set_registers)

    parser_get_registers = subparsers.add_parser('get-registers', help='gets a register\'s value from an FSCC port')
    parser_get_registers.add_argument('port', type=str, help='the fscc node to get a register\'s value from')
    parser_get_registers.set_defaults(func=get_registers)

    parser_flush_tx = subparsers.add_parser('flush-tx', help='Removes all pending transmit data')
    parser_flush_tx.add_argument('port', type=str, nargs='+', help='the fscc node to remove its pending data')
    parser_flush_tx.set_defaults(func=flush_tx)

    parser_flush_rx = subparsers.add_parser('flush-rx', help='Removes all pending receive data')
    parser_flush_rx.add_argument('port', type=str, nargs='+', help='the fscc node to remove its pending data')
    parser_flush_rx.set_defaults(func=flush_rx)

    args = parser.parse_args()
    args.func(args)
