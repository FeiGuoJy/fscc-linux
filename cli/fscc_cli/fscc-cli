#!/usr/bin/python3

"""
        Copyright (C) 2012 Commtech, Inc.

        This file is part of fscc-linux.

        fscc-linux is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        fscc-linux is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with fscc-linux.  If not, see <http://www.gnu.org/licenses/>.

"""

import sys
import binascii
import subprocess
import textwrap
import os.path

import argparse

from fscc import port as fscc_port


def write(args):
    outgoing_data = args.data.encode()

    try:
        if args.hex:
            outgoing_data = binascii.b2a_hex(outgoing_data)
    except:
        pass

    port = fscc_port.Port(args.port, "wb")

    for i in range(args.iterations):
        port.write(outgoing_data)

    port.close()


def read(args):
    port = fscc_port.Port(args.port, "rb")

    old_status = port.append_status

    if args.append_status == 0:
        port.append_status = False
    else:
        port.append_status = True

    for i in range(args.iterations):
        incoming_data = port.read(args.max_bytes)

        if args.hex:
            incoming_data = binascii.a2b_hex(incoming_data)

        print(incoming_data)

    port.append_status = old_status

    port.close()


def purge(args):
    port = fscc_port.Port(args.port, "wb")

    port.purge(not args.ignore_tx, not args.ignore_rx)

    port.close()


def registers(args):
    port = fscc_port.Port(args.port, "w+")

    if args.values == None:
        port.registers.export_to_file(sys.stdout)
    else:
        if os.path.exists(args.values):
            file_path = args.values
        else:
            file_path = "/tmp/fscc_settings"

            import_file = open(file_path, "w+")

            for line in args.values.split("\n"):
                import_file.write("%s\n" % line)

            import_file.close()

        import_file = open(file_path, "r")

        port.registers.import_from_file(import_file)

        import_file.close()

    port.close()


def set_clock(args):
    if args.frequency < 20000 or args.frequency > 200000000:
        sys.stderr.write("Error: frequency out of allowed range (20kHz - " \
                         "200MHz).\n")
        return -1

    if args.frequency > 50000000:
        sys.stdout.write("Warning: frequency above recommended range (20kHz " \
                         "- 50Mhz).\n")
        return 0

    for port_name in args.port:
        retcode = subprocess.call([os.path.dirname(__file__) +
                                  "/fscc-set-clock",
                                  port_name, str(args.frequency), "1"])

        if retcode != 0:
            return retcode


def input_memcap(args):
    port = fscc_port.Port(args.port, "wb")

    if args.value is not None:
        port.input_memory_cap = args.value
    else:
        print(port.input_memory_cap)

    port.close()


def output_memcap(args):
    port = fscc_port.Port(args.port, "wb")

    if args.value is not None:
        port.output_memory_cap = args.value
    else:
        print(port.output_memory_cap)

    port.close()


def tx_modifiers(args):
    port = fscc_port.Port(args.port, "wb")

    if args.value is not None:
        port.tx_modifiers = args.value
    else:
        print(port.tx_modifiers)

    port.close()


def ignore_timeout(args):
    port = fscc_port.Port(args.port, "wb")

    if args.value is not None:
        port.ignore_timeout = args.value
    else:
        print(port.ignore_timeout)

    port.close()


port_description = """the FSCC port to interact with"""

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.description = 'Tools for using the Commtech FSCC line of cards.'

    subparsers = parser.add_subparsers(title='subcommands')

    #
    pwrite = subparsers.add_parser('write')
    pwrite.help = 'Sends a frame of data out of an FSCC port.'
    pwrite.description = pwrite.help
    pwrite.formatter_class = argparse.RawTextHelpFormatter
    pwrite.set_defaults(func=write)

    pwrite.add_argument('port', help=port_description)
    pwrite.add_argument('data', help='the data to send out of the port')
    pwrite.add_argument('--hex', default=False, action='store_true',
                        help='transfer the data in hexidecimal')
    pwrite.add_argument('-i', '--iterations', type=int, default=1,
                        help='the number of (frames/streams) to transmit')

    pwrite.epilog = \
    textwrap.dedent("""
    examples:
      # Send a frame/stream as ascii data.
      fscc-cli write /dev/fscc0 "0123456789ABCDEF"

      # Send a frame/stream as hexidecimal data.
      fscc-cli write --hex /dev/fscc0 "0123456789ABCDEF"

      # Send three frames/streams.
      fscc-cli write --iterations 3 /dev/fscc0 "0123456789ABCDEF"

    """)

    #
    pread = subparsers.add_parser('read')
    pread.help = 'Receives a frame of data from an FSCC port.'
    pread.description = pread.help
    pread.formatter_class = argparse.RawTextHelpFormatter
    pread.set_defaults(func=read)

    pread.add_argument('port', help=port_description)
    pread.add_argument('-a', '--append-status', default=False,
                       action='store_true',
                       help='append the status bytes to the data')
    pread.add_argument('--hex', default=False, action='store_true',
                       help='display the data in hexidecimal')
    pread.add_argument('-m', '--max-bytes', type=int, default=4096,
                       help='the largest frame size in frame based mode or ' \
                       'how much data to read in transparent')
    pread.add_argument('-i', '--iterations', type=int, default=1,
                       help='the number of (frames/streams) to receive')

    pread.epilog = \
    textwrap.dedent("""
    examples:
      # Read in a frame/stream as ascii data.
      fscc-cli read /dev/fscc0
      > b'0123456789ABCDEF'

      # Read in a frame/stream as hexidecimal data.
      fscc-cli read --hex /dev/fscc0
      b'\\x01#Eg\\x89\\xab\\xcd\\xef'

      # Read in three frames/streams.
      fscc-cli read --iterations 3 /dev/fscc0
      > b'0123456789ABCDEF'
      > b'0123456789ABCDEF'
      > b'0123456789ABCDEF'

    """)

    #
    ppurge = subparsers.add_parser('purge')
    ppurge.help = 'Removes pending data from an FSCC port.'
    ppurge.description = ppurge.help
    ppurge.formatter_class = argparse.RawTextHelpFormatter
    ppurge.set_defaults(func=purge)

    ppurge.add_argument('port', help=port_description)
    ppurge.add_argument('--ignore-tx', default=False, action='store_true',
                        help='prevent purging the transmit side')
    ppurge.add_argument('--ignore-rx', default=False, action='store_true',
                        help='prevent purging the receive side')

    ppurge.epilog = \
    textwrap.dedent("""
    examples:
      # Purge data from both the transmit and receive sides.
      fscc-cli purge /dev/fscc0

      # Purge data from the receive side only.
      fscc-cli purge /dev/fscc0 --ignore-tx

      # Purge data from the transmit side only.
      fscc-cli purge /dev/fscc0 --ignore-rx

    """)

    #
    pregisters = subparsers.add_parser('registers')
    pregisters.help = 'Set/get the register value(s) of an FSCC port.'
    pregisters.description = pregisters.help
    pregisters.formatter_class = argparse.RawTextHelpFormatter
    pregisters.set_defaults(func=registers)

    pregisters.add_argument('port', help=port_description)
    pregisters.add_argument('values', nargs='?',
                            help='the new register value(s) (file or string)')

    pregisters.epilog = \
    textwrap.dedent("""
    examples:
      # Set the BGR register to a value of 1
      fscc-cli registers /dev/fscc0 "BGR = 0x00000001"

    """)

    #
    pimemcap = subparsers.add_parser('input-memcap')
    pimemcap.help = 'Set/get the input memory cap of an FSCC port.'
    pimemcap.description = pimemcap.help
    pimemcap.formatter_class = argparse.RawTextHelpFormatter
    pimemcap.set_defaults(func=input_memcap)

    pimemcap.add_argument('port', help=port_description)
    pimemcap.add_argument('value', nargs='?', type=int,
                          help='the new \'memory cap\' value')

    pimemcap.epilog = \
    textwrap.dedent("""
    examples:
      # Set the memory cap to 10000.
      > fscc-cli input-memcap /dev/fscc0 10000

      # Get the current memory cap.
      > fscc-cli input-memcap /dev/fscc0
      10000

    """)

    #
    pomemcap = subparsers.add_parser('output-memcap')
    pomemcap.help = 'Set/get the output memory cap of an FSCC port.'
    pomemcap.description = pomemcap.help
    pomemcap.formatter_class = argparse.RawTextHelpFormatter
    pomemcap.set_defaults(func=output_memcap)

    pomemcap.add_argument('port', help=port_description)
    pomemcap.add_argument('value', nargs='?', type=int,
                          help='the new \'memory cap\' value')

    pomemcap.epilog = \
    textwrap.dedent("""
    examples:
      # Set the memory cap to 10000.
      > fscc-cli output-memcap /dev/fscc0 10000

      # Get the current memory cap.
      > fscc-cli output-memcap /dev/fscc0
      10000

    """)

    #
    ptx_modifiers = subparsers.add_parser('tx-modifiers')
    ptx_modifiers.help = 'Set/get the transmit modifiers of an FSCC port.'
    ptx_modifiers.description = ptx_modifiers.help
    ptx_modifiers.formatter_class = argparse.RawTextHelpFormatter
    ptx_modifiers.set_defaults(func=tx_modifiers)

    ptx_modifiers.add_argument('port', help=port_description)
    ptx_modifiers.add_argument('value', nargs='?', type=int,
                               help='the new \'transmit modifiers\' value')

    ptx_modifiers.epilog = \
    textwrap.dedent("""
    examples:
      # XF(0) - Normal transmit - disable modifiers
      # XREP(1) - Transmit repeat
      # TXT(2) - Transmit on timer
      # TXEXT(4) - Transmit on external signal

      # Set the transmit modifiers to TXT(2) & XREP(1).
      > fscc-cli tx-modifiers /dev/fscc0 3

      # Get the current transmit modifiers.
      > fscc-cli tx-modifiers /dev/fscc0
      3

    """)

    #
    pignore_timeout = subparsers.add_parser('ignore-timeout')
    pignore_timeout.help = 'Set/get the ignore timeout value of an FSCC port.'
    pignore_timeout.description = pignore_timeout.help
    pignore_timeout.formatter_class = argparse.RawTextHelpFormatter
    pignore_timeout.set_defaults(func=ignore_timeout)

    pignore_timeout.add_argument('port', help=port_description)
    pignore_timeout.add_argument('value', nargs='?', type=int,
                                 help='the new \'ignore timeout\' value')

    pignore_timeout.epilog = \
    textwrap.dedent("""
    examples:
      # Disable ignore timeout.
      > fscc-cli ignore-timeout /dev/fscc0 0

      # Get current ignore timeout value.
      > fscc-cli ignore-timeout /dev/fscc0
      0

    """)

    """

    parser_set_clock = subparsers.add_parser('set-clock',
                                             help='Sets clock frequency')
    parser_set_clock.add_argument('port', type=str, nargs='+',
                                  help='the fscc node to have its clock set')
    parser_set_clock.add_argument('frequency', type=int, default=0,
                                  help='TODO')
    parser_set_clock.set_defaults(func=set_clock)
    """

    args = parser.parse_args()
    args.func(args)
