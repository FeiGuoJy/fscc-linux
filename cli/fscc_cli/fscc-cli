#!/usr/bin/python3

"""
        Copyright (C) 2011 Commtech, Inc.

        This file is part of fscc-linux.

        fscc-linux is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        fscc-linux is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with fscc-linux.  If not, see <http://www.gnu.org/licenses/>.

"""

import random
import string
import sys
import binascii
import threading
import subprocess
import os.path

import argparse

from fscc import port as fscc_port

def write(args):
    outgoing_data = args.data.encode()

    try:
        if args.hex:
            outgoing_data = binascii.b2a_hex(outgoing_data)
    except:
        pass

    for port_name in args.port:
        port = fscc_port.Port(port_name, "wb")

        for i in range(args.iterations):
            port.write(outgoing_data)

        port.close()


def read(args):
    port = fscc_port.Port(args.port, "rb")
    
    old_status = port.append_status
    
    if args.append_status == 0:
        port.append_status = False
    else:
        port.append_status = True

    for i in range(args.iterations):
        incoming_data = port.read(args.length)

        if args.hex:
            incoming_data = binascii.a2b_hex(incoming_data)

        print(incoming_data)
        
    port.append_status = old_status

    port.close()


def purge(args):
    port = fscc_port.Port(args.port, "wb")

    port.purge(not args.ignore_tx, not args.ignore_rx)
        
    port.close()

        
def registers(args):
    port = fscc_port.Port(args.port, "w+")
    
    if args.values == None:
        port.registers.export_to_file(sys.stdout)
    else:
        if os.path.exists(args.values):
            file_path = args.values
        else:
            file_path = "/tmp/fscc_settings"
            
            import_file = open(file_path, "w+")

            for line in args.values.split("\n"):
                import_file.write("%s\n" % line)

            import_file.close()

        import_file = open(file_path, "r")

        port.registers.import_from_file(import_file)

        import_file.close()
        
    port.close()


def set_clock(args):
    if args.frequency < 20000 or args.frequency > 200000000:
        sys.stderr.write("Error: frequency out of allowed range (20kHz - 200MHz).\n")
        return -1

    if args.frequency > 50000000:
        sys.stdout.write("Warning: frequency above recommended range (20kHz - 50Mhz).\n")
        return 0

    for port_name in args.port:
        retcode = subprocess.call([os.path.dirname(__file__) + "/fscc-set-clock", port_name, str(args.frequency), "1"])

        if retcode != 0:
            return retcode


def input_memcap(args):
    port = fscc_port.Port(args.port, "wb")
    
    if args.value:
        port.input_memory_cap = args.value
    else:
        print(port.input_memory_cap)
        
    port.close()


def output_memcap(args):
    port = fscc_port.Port(args.port, "wb")
    
    if args.value:
        port.output_memory_cap = args.value
    else:
        print(port.output_memory_cap)
        
    port.close()


def tx_modifiers(args):
    port = fscc_port.Port(args.port, "wb")

    if args.value:
        port.tx_modifiers = args.value
    else:
        print(port.tx_modifiers)
        
    port.close()


def ignore_timeout(args):
    port = fscc_port.Port(args.port, "wb")

    if args.value:
        port.ignore_timeout = args.value
    else:
        print(port.ignore_timeout)
        
    port.close()


main_description = """Tools for using the Commtech FSCC line of cards."""
port_description = """the FSCC port to interact with"""
write_description = """Sends a frame of data out of an FSCC port."""
read_description = """Receives a frame of data from an FSCC port."""
purge_description = """Removes pending data from an FSCC port."""

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=main_description)
    subparsers = parser.add_subparsers(title='subcommands')

    #
    pwrite = subparsers.add_parser('write')
   
    pwrite.description = write_description
    pwrite.help = write_description
    pwrite.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    pwrite.set_defaults(func=write)
    
    pwrite.add_argument('port', nargs='+', help=port_description)
    pwrite.add_argument('data', 
                        help='the data to send out of the port')
    pwrite.add_argument('--hex', default=False, action='store_true', 
                        help='whether or not the data is hexidecimal')
    pwrite.add_argument('-i', '--iterations', type=int, default=1, 
                        help='how many times to transmit the data')
    
    #
    pread = subparsers.add_parser('read')
    
    pread.description = read_description
    pread.help = read_description
    pread.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    pread.set_defaults(func=read)
    
    pread.add_argument('port', help=port_description)
    pread.add_argument('-a', '--append-status', default=False, action='store_true',
                       help='whether or not to append the status bytes to the data')
    pread.add_argument('--hex', default=False, action='store_true', 
                       help='whether or not the data is hexidecimal')
    pread.add_argument('-l', '--length', type=int, default=4096, 
                       help='the largest frame size in frame based mode or how much data to read in transparent')
    pread.add_argument('-i', '--iterations', type=int, default=1, 
                       help='how many times to read in data')

    #
    ppurge = subparsers.add_parser('purge')

    ppurge.description = purge_description
    ppurge.help = purge_description
    ppurge.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ppurge.set_defaults(func=purge)
    
    ppurge.add_argument('port',
                        help='the fscc node to remove its pending data')
    ppurge.add_argument('--ignore-tx', default=False, action='store_true',
                        help='prevent purging the transmit side')
    ppurge.add_argument('--ignore-rx', default=False, action='store_true',
                        help='prevent purging the receive side')

    #
    pregisters = subparsers.add_parser('registers')
    
    pregisters.description = 'sets the register\'s values of an FSCC port'
    pregisters.help = 'sets the register\'s values of an FSCC port'
    pregisters.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    pregisters.set_defaults(func=registers)
    
    pregisters.add_argument('port', 
                            help='the fscc node to have it\'s registers set.')
    pregisters.add_argument('values', nargs='?',
                            help='the register values to set (file or string)')

    #
    pimemcap = subparsers.add_parser('input-memcap')
    
    pimemcap.description = 'TODO'
    pimemcap.help = 'TODO'
    pimemcap.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    pimemcap.set_defaults(func=input_memcap)
    
    pimemcap.add_argument('port', help='TODO')
    pimemcap.add_argument('value', nargs='?', type=int, help='TODO')

    #
    pomemcap = subparsers.add_parser('output-memcap')
    
    pomemcap.description = 'TODO'
    pomemcap.help = 'TODO'
    pomemcap.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    pomemcap.set_defaults(func=output_memcap)
    
    pomemcap.add_argument('port', help='TODO')
    pomemcap.add_argument('value', nargs='?', type=int, help='TODO')

    #
    ptx_modifiers = subparsers.add_parser('tx-modifiers')
    
    ptx_modifiers.description = 'Sets transmit modifiers'
    ptx_modifiers.help = 'Sets transmit modifiers'
    ptx_modifiers.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ptx_modifiers.set_defaults(func=tx_modifiers)
    
    ptx_modifiers.add_argument('port',
                               help='the fscc node to have it\'s modifiers set')
    ptx_modifiers.add_argument('value', nargs='?', type=int, help='TODO')

    #
    pignore_timeout = subparsers.add_parser('ignore-timeout')
    
    pignore_timeout.description = 'TODO'
    pignore_timeout.help = 'TODO'
    pignore_timeout.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    pignore_timeout.set_defaults(func=ignore_timeout)
    
    pignore_timeout.add_argument('port', help='TODO')
    pignore_timeout.add_argument('value', nargs='?', type=int, help='TODO')
    
    """

    parser_set_clock = subparsers.add_parser('set-clock', help='Sets clock frequency')
    parser_set_clock.add_argument('port', type=str, nargs='+', help='the fscc node to have its clock set')
    parser_set_clock.add_argument('frequency', type=int, default=0, help='TODO')
    parser_set_clock.set_defaults(func=set_clock)
    """    
    
    args = parser.parse_args()
    args.func(args)
