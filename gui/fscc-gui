#!/usr/bin/python

"""
        Copyright (C) 2011 Commtech, Inc.

        This file is part of fscc-linux.

        fscc-linux is free software: you can redistribute it and/or modify
        it under the terms of the GNU General Public License as published by
        the Free Software Foundation, either version 3 of the License, or
        (at your option) any later version.

        fscc-linux is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        GNU General Public License for more details.

        You should have received a copy of the GNU General Public License
        along with fscc-linux.  If not, see <http://www.gnu.org/licenses/>.

"""

import gtk
import gobject

import fscc

from widgets import generic, registers, dialogs
import config


class MenuBar(gtk.MenuBar):

    def __init__(self, accel_group):
        super(MenuBar, self).__init__()

        file_menu = gtk.Menu()
        file_menu.show()

        file_menu_item = gtk.MenuItem("_File")
        file_menu_item.set_submenu(file_menu)
        file_menu_item.show()

        open_menu_item = gtk.ImageMenuItem(gtk.STOCK_OPEN, accel_group)
        key, mod = gtk.accelerator_parse("O")
        open_menu_item.add_accelerator("activate", accel_group, key, mod, gtk.ACCEL_VISIBLE)
        open_menu_item.connect("activate", self.open_activate)
        file_menu.append(open_menu_item)
        open_menu_item.show()

        seperator = gtk.SeparatorMenuItem()
        file_menu.append(seperator)
        seperator.show()

        exit_menu_item = gtk.ImageMenuItem(gtk.STOCK_QUIT, accel_group)
        key, mod = gtk.accelerator_parse("Q")
        exit_menu_item.add_accelerator("activate", accel_group, key, mod, gtk.ACCEL_VISIBLE)
        exit_menu_item.connect("activate", gtk.main_quit)
        file_menu.append(exit_menu_item)
        exit_menu_item.show()

        help_menu = gtk.Menu()
        help_menu.show()

        help_menu_item = gtk.MenuItem("Help")
        help_menu_item.set_submenu(help_menu)
        help_menu_item.show()

        about_menu_item = gtk.ImageMenuItem(gtk.STOCK_ABOUT, accel_group)
        about_menu_item.connect("activate", self.about_activate)
        help_menu.append(about_menu_item)
        about_menu_item.show()

        for widget in [file_menu_item, help_menu_item]:
            self.append(widget)

    def open_activate(self, widget, data=None):
        dialog = dialogs.OpenPortDialog()

        if dialog.run() == gtk.RESPONSE_OK:
            port_name = dialog.get_filename()
        else:
            port_name = None

        dialog.destroy()

        if port_name:
            self.emit("port-selected", port_name)

    def about_activate(self, widget, data=None):
        about_dialog = dialogs.AboutDialog()
        about_dialog.run()
        about_dialog.destroy()


gobject.type_register(MenuBar)

gobject.signal_new("port-selected", MenuBar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))


class Toolbar(gtk.Toolbar):
    port_dependent_buttons = [
        gtk.STOCK_SAVE,
        gtk.STOCK_REFRESH,
        gtk.STOCK_GO_FORWARD,
        gtk.STOCK_GO_BACK,
        gtk.STOCK_NETWORK,
    ]

    def __init__(self, window):
        super(Toolbar, self).__init__()

        button_data = (
            (gtk.STOCK_OPEN, self.open_clicked, "Open Port",
            "Open a port"),
            (gtk.STOCK_SAVE, self.save_clicked, "Save Settings",
            "Save settings to port"),
            (gtk.STOCK_REFRESH, self.refresh_clicked, "Reload Settings",
            "Reload settings from port"),
            (gtk.STOCK_GO_FORWARD, self.export_clicked, "Export Settings",
            "Export settings to file"),
            (gtk.STOCK_GO_BACK, self.import_clicked, "Import Settings",
            "Import settings from file"),
            (gtk.STOCK_NETWORK, self.terminal_clicked, "Terminal",
            "Open terminal to port"),
        )

        for stock_id, callback, label, tooltip_text in button_data:
            button = gtk.ToolButton(stock_id)
            button.connect("clicked", callback)
            button.show()

            if label:
                button.set_label(label)

            if tooltip_text:
                button.set_tooltip_text(tooltip_text)

            setattr(self, stock_id, button)
            self.insert(button, -1)

        for i in [2, 6]:
            separator = gtk.SeparatorToolItem()
            separator.show()

            self.insert(separator, i)

        window.connect("port-changed", self.port_changed)

        for stock_id in Toolbar.port_dependent_buttons:
            getattr(self, stock_id).set_sensitive(False)

    def open_clicked(self, widget, data=None):
        dialog = dialogs.OpenPortDialog()

        if dialog.run() == gtk.RESPONSE_OK:
            port_name = dialog.get_filename()
        else:
            port_name = None

        dialog.destroy()

        if port_name:
            self.emit("port-selected", port_name)

    def save_clicked(self, widget, data=None):
        self.emit("save-clicked")

    def refresh_clicked(self, widget, data=None):
        self.emit("refresh-clicked")

    def export_clicked(self, widget, data=None):
        dialog = dialogs.ExportSettingsDialog()

        if dialog.run() == gtk.RESPONSE_OK:
            filename = dialog.get_filename()
        else:
            filename = None

        dialog.destroy()

        if filename:
            self.emit("export-clicked", filename)

    def import_clicked(self, widget, data=None):
        dialog = dialogs.ImportSettingsDialog()

        if dialog.run() == gtk.RESPONSE_OK:
            filename = dialog.get_filename()
        else:
            filename = None

        dialog.destroy()

        if filename:
            self.emit("import-clicked", filename)

    def terminal_clicked(self, widget, data=None):
        self.emit("terminal-clicked")

    def port_changed(self, widget, data=None):
        for stock_id in Toolbar.port_dependent_buttons:
            getattr(self, stock_id).set_sensitive(True)


gobject.type_register(Toolbar)

gobject.signal_new("port-selected", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))

gobject.signal_new("save-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, ())

gobject.signal_new("refresh-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, ())

gobject.signal_new("export-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))

gobject.signal_new("import-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))

gobject.signal_new("terminal-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, ())


class Window(gtk.Window):

    editable_register_names = [r for r in fscc.Port.Registers.editable_register_names if r not in ["CMDR"]]

    def __init__(self):
        super(Window, self).__init__(gtk.WINDOW_TOPLEVEL)

        self.set_title(config.NAME)
        self.set_position(gtk.WIN_POS_CENTER)
        self.set_default_size(500, 0)

        self.connect("destroy", gtk.main_quit)

        accel_group = gtk.AccelGroup()
        self.add_accel_group(accel_group)

        main_vbox = gtk.VBox(False, 0)

        menu_bar = MenuBar(accel_group)
        menu_bar.connect("port-selected", self.change_port_selected)
        menu_bar.show()

        toolbar = Toolbar(self)
        toolbar.connect("port-selected", self.change_port_selected)
        toolbar.connect("save-clicked", self.save_registers)
        toolbar.connect("refresh-clicked", self.update_registers)
        toolbar.connect("export-clicked", self.export_settings)
        toolbar.connect("import-clicked", self.import_settings)
        toolbar.connect("terminal-clicked", self.start_terminal)
        toolbar.show()

        registers_hbox = gtk.HBox(False, 3)
        registers_hbox.show()

        register_entries_vbox = gtk.VBox(False, 3)
        register_entries_vbox.set_border_width(10)
        register_entries_vbox.show()

        separator = gtk.VSeparator()
        separator.show()

        register_guis_vbox = gtk.VBox(False, 3)
        register_guis_vbox.set_border_width(10)
        register_guis_vbox.set_size_request(800, -1)
        register_guis_vbox.show()

        self.port_name = gtk.Label()
        self.port_name.set_alignment(0.5, 0)

        vbox = gtk.VBox(False, 0)
        vbox.show()

        vbox.pack_start(self.port_name, False, False, 10)
        vbox.pack_start(register_entries_vbox, True, True)

        for i, register_name in enumerate(Window.editable_register_names):
            register = generic.Register(register_name)
            setattr(self, register_name.lower(), register)
            register.entry.connect("focus-in-event", self.entry_selected)
            register.show()

            try:
                gui = getattr(registers, register_name)(register.entry)
            except AttributeError:
                pass
            else:
                register.set_verbose_widget(gui)
                register_guis_vbox.pack_start(gui, False, False, 3)

            register_entries_vbox.pack_start(register, False, False, 0)

        registers_hbox.pack_start(vbox, False, False, 0)
        registers_hbox.pack_start(register_guis_vbox, True, True, 15)

        for widget in [menu_bar, toolbar, registers_hbox]:
            main_vbox.pack_start(widget, False, False, 0)

        main_vbox.show()

        self.change_port("/dev/fscc0")

        self.add(main_vbox)

    def entry_selected(self, widget, data=None):
        for register_name in Window.editable_register_names:
            getattr(self, register_name.lower()).hide_gui()

        getattr(self, widget.register_name.lower()).show_gui()

    def change_port_selected(self, widget, port_name):
        try:
            fscc.Port(port_name, 'w+b')
        except IOError as e:
            if e.errno == 13:
                dialog = dialogs.InsufficientPermissionsDialog()
            else:
                dialog = dialogs.InvalidPortDialog()

            dialog.run()
            dialog.destroy()
        else:
            self.change_port(port_name)

    def change_port(self, port_name):
        try:
            self.port = fscc.Port(port_name, 'w+b')
        except IOError:
            pass
        else:
            for register_name in Window.editable_register_names:
                value = getattr(self.port.registers, register_name)
                getattr(self, register_name.lower()).set_value(value)

            vstr = self.port.registers.VSTR

            prev = (vstr & 0x0000FF00) >> 8
            frev = vstr & 0x000000FF

            self.port_name.set_markup("<b>%s</b> (<i>%x.%02x</i>)" % (port_name, prev, frev))
            self.port_name.show()

            self.emit("port-changed", port_name)

    def save_registers(self, widget=None):
        invalid_values = []

        for i, register_name in enumerate(Window.editable_register_names):
            try:
                value = getattr(self, register_name.lower()).get_value()
            except ValueError:
                invalid_values.append((register_name, value))

        if invalid_values:
            dialog = dialogs.InvalidValuesDialog(invalid_values)
            dialog.run()
            dialog.destroy()

            return

        for register_name in Window.editable_register_names:
            value = getattr(self, register_name.lower()).get_value()
            setattr(self.port.registers, register_name, value)

        dialog = dialogs.SettingsSavedDialog()
        dialog.run()
        dialog.destroy()

    def update_registers(self, widget=None):
        for register_name in Window.editable_register_names:
            value = getattr(self.port.registers, register_name)
            getattr(self, register_name.lower()).set_value(value)

    def export_settings(self, widget, filename):
        registers = fscc.Port.Registers()

        for register_name in Window.editable_register_names:
            value = getattr(self, register_name.lower()).get_value()
            setattr(registers, register_name, value)

        export_file = open(filename, 'w')
        registers.export_to_file(export_file)
        export_file.close()

        dialog = dialogs.SettingsExportedDialog()
        dialog.run()
        dialog.destroy()

    def import_settings(self, widget, filename):
        registers = fscc.Port.Registers()

        import_file = open(filename, "r")
        registers.import_from_file(import_file)
        import_file.close()

        for register_name in Window.editable_register_names:
            value = getattr(registers, register_name)

            if value >= 0:
                getattr(self, register_name.lower()).set_value(value)

        dialog = dialogs.SettingsImportedDialog()
        dialog.run()
        dialog.destroy()

    def start_terminal(self, widget, data=None):
        terminal_dialog = dialogs.TerminalDialog(self.port)

        terminal_dialog.run()
        terminal_dialog.destroy()


gobject.type_register(Window)

gobject.signal_new("port-changed", Window, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))


if __name__ == "__main__":
    fscc_window = Window()
    fscc_window.show()

    gobject.threads_init()
    gtk.main()
