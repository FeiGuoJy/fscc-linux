#!/usr/bin/python

import gtk
import gobject
import threading

import fscc

from widgets import generic, registers, dialogs
import config


class ChatDialog(gtk.Dialog):
    class ReadThread(threading.Thread, gobject.GObject):
        def __init__(self, port):
            threading.Thread.__init__(self)
            gobject.GObject.__init__(self)

            self.port = port

        def run(self):
            while True:
                text = self.port.read(4096)
                self.emit("changed", text)

    def __init__(self, port):
        buttons = (
            gtk.STOCK_CLOSE,
            gtk.RESPONSE_CLOSE,
        )

        super(ChatDialog, self).__init__("FSCC Send/Receive", buttons=buttons)

        self.set_border_width(10)
        self.set_default_size(600, 400)

        paned = gtk.VPaned()
        paned.set_position(200)
        paned.show()

        self.outgoing_text = gtk.TextView()
        self.outgoing_text.show()

        send_button = gtk.Button("Send")
        send_button.connect("clicked", self.send_clicked)
        send_button.show()

        button_box = gtk.HButtonBox()
        button_box.set_layout(gtk.BUTTONBOX_END)
        button_box.set_spacing(5)
        button_box.show()
        button_box.pack_start(send_button, False, False)

        vbox = gtk.VBox()
        vbox.show()
        vbox.pack_start(self.outgoing_text, True, True, 5)
        vbox.pack_start(button_box, False, False, 5)

        paned.add(vbox)

        self.incoming_text = gtk.Label()
        self.incoming_text.set_alignment(0, 0)
        self.incoming_text.show()

        vbox = gtk.VBox()
        vbox.set_border_width(5)
        vbox.pack_start(self.incoming_text, True, True)
        vbox.show()

        scrolled_window = gtk.ScrolledWindow()
        scrolled_window.add_with_viewport(vbox)
        scrolled_window.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        scrolled_window.set_shadow_type(gtk.SHADOW_NONE)
        scrolled_window.show()

        frame = gtk.Frame("Incoming")
        frame.add(scrolled_window)
        frame.set_shadow_type(gtk.SHADOW_NONE)
        frame.show()

        paned.add(frame)

        self.vbox.pack_start(paned, True, True, 5)

        self.port = port

        read_thread = ChatDialog.ReadThread(self.port)
        read_thread.connect("changed", self.incoming_text_changed)
        read_thread.daemon = True
        read_thread.start()

    def send_clicked(self, widget, data=None):
        text_buffer = self.outgoing_text.get_buffer()
        start, end = text_buffer.get_bounds()

        text = text_buffer.get_text(start, end)
        text_buffer.delete(start, end)

        self.port.write(text)

    def incoming_text_changed(self, widget, text):
        self.incoming_text.set_text(text)


gobject.type_register(ChatDialog.ReadThread)

gobject.signal_new("changed", ChatDialog.ReadThread, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))


class MenuBar(gtk.MenuBar):

    def __init__(self, accel_group):
        super(MenuBar, self).__init__()

        file_menu = gtk.Menu()
        file_menu.show()

        file_menu_item = gtk.MenuItem("_File")
        file_menu_item.set_submenu(file_menu)
        file_menu_item.show()

        open_menu_item = gtk.ImageMenuItem(gtk.STOCK_OPEN, accel_group)
        key, mod = gtk.accelerator_parse("O")
        open_menu_item.add_accelerator("activate", accel_group, key, mod, gtk.ACCEL_VISIBLE)
        open_menu_item.connect("activate", self.open_activate)
        file_menu.append(open_menu_item)
        open_menu_item.show()

        seperator = gtk.SeparatorMenuItem()
        file_menu.append(seperator)
        seperator.show()

        exit_menu_item = gtk.ImageMenuItem(gtk.STOCK_QUIT, accel_group)
        key, mod = gtk.accelerator_parse("Q")
        exit_menu_item.add_accelerator("activate", accel_group, key, mod, gtk.ACCEL_VISIBLE)
        exit_menu_item.connect("activate", gtk.main_quit)
        file_menu.append(exit_menu_item)
        exit_menu_item.show()

        help_menu = gtk.Menu()
        help_menu.show()

        help_menu_item = gtk.MenuItem("Help")
        help_menu_item.set_submenu(help_menu)
        help_menu_item.show()

        about_menu_item = gtk.ImageMenuItem(gtk.STOCK_ABOUT, accel_group)
        about_menu_item.connect("activate", self.about_activate)
        help_menu.append(about_menu_item)
        about_menu_item.show()

        for widget in [file_menu_item, help_menu_item]:
            self.append(widget)

    def open_activate(self, widget, data=None):
        dialog = dialogs.OpenPortDialog()

        if dialog.run() == gtk.RESPONSE_OK:
            port_name = dialog.get_filename()
        else:
            port_name = None

        dialog.destroy()

        if port_name:
            self.emit("port-selected", port_name)

    def about_activate(self, widget, data=None):
        about_dialog = dialogs.AboutDialog()
        about_dialog.run()
        about_dialog.destroy()


gobject.type_register(MenuBar)

gobject.signal_new("port-selected", MenuBar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))


class Toolbar(gtk.Toolbar):
    port_dependent_buttons = [
        gtk.STOCK_SAVE,
        gtk.STOCK_REFRESH,
        gtk.STOCK_GO_FORWARD,
        gtk.STOCK_GO_BACK,
        gtk.STOCK_CONNECT,
    ]

    def __init__(self, window):
        super(Toolbar, self).__init__()

        button_data = (
            (gtk.STOCK_OPEN, self.open_clicked, "Open Port",
            "Open a port"),
            (gtk.STOCK_SAVE, self.save_clicked, "Save Settings",
            "Save settings to port"),
            (gtk.STOCK_REFRESH, self.refresh_clicked, "Reload Settings",
            "Reload settings from port"),
            (gtk.STOCK_GO_FORWARD, self.export_clicked, "Export Settings",
            "Export settings to file"),
            (gtk.STOCK_GO_BACK, self.import_clicked, "Import Settings",
            "Import settings from file"),
            (gtk.STOCK_CONNECT, self.chat_clicked, "Send/Receive Data",
            "Send/receive data to/from port"),
        )

        for stock_id, callback, label, tooltip_text in button_data:
            button = gtk.ToolButton(stock_id)
            button.connect("clicked", callback)
            button.show()

            if label:
                button.set_label(label)

            if tooltip_text:
                button.set_tooltip_text(tooltip_text)

            setattr(self, stock_id, button)
            self.insert(button, -1)

        for i in [2, 6]:
            separator = gtk.SeparatorToolItem()
            separator.show()

            self.insert(separator, i)

        window.connect("port-changed", self.port_changed)

        for stock_id in Toolbar.port_dependent_buttons:
            getattr(self, stock_id).set_sensitive(False)

    def open_clicked(self, widget, data=None):
        dialog = dialogs.OpenPortDialog()

        if dialog.run() == gtk.RESPONSE_OK:
            port_name = dialog.get_filename()
        else:
            port_name = None

        dialog.destroy()

        if port_name:
            self.emit("port-selected", port_name)

    def save_clicked(self, widget, data=None):
        self.emit("save-clicked")

    def refresh_clicked(self, widget, data=None):
        self.emit("refresh-clicked")

    def export_clicked(self, widget, data=None):
        dialog = dialogs.ExportSettingsDialog()

        if dialog.run() == gtk.RESPONSE_OK:
            filename = dialog.get_filename()
        else:
            filename = None

        dialog.destroy()

        if filename:
            self.emit("export-clicked", filename)

    def import_clicked(self, widget, data=None):
        dialog = dialogs.ImportSettingsDialog()

        if dialog.run() == gtk.RESPONSE_OK:
            filename = dialog.get_filename()
        else:
            filename = None

        dialog.destroy()

        if filename:
            self.emit("import-clicked", filename)

    def chat_clicked(self, widget, data=None):
        self.emit("chat-clicked")

    def port_changed(self, widget, data=None):
        for stock_id in Toolbar.port_dependent_buttons:
            getattr(self, stock_id).set_sensitive(True)


gobject.type_register(Toolbar)

gobject.signal_new("port-selected", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))

gobject.signal_new("save-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, ())

gobject.signal_new("refresh-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, ())

gobject.signal_new("export-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))

gobject.signal_new("import-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))

gobject.signal_new("chat-clicked", Toolbar, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, ())


class Window(gtk.Window):

    editable_register_names = [r for r in fscc.Port.Registers.editable_register_names if r not in ["CMDR"]]

    def __init__(self):
        super(Window, self).__init__(gtk.WINDOW_TOPLEVEL)

        self.set_title(config.NAME)
        self.set_position(gtk.WIN_POS_CENTER)
        self.set_default_size(600, 0)

        self.connect("destroy", gtk.main_quit)

        accel_group = gtk.AccelGroup()
        self.add_accel_group(accel_group)

        main_vbox = gtk.VBox(False, 0)

        menu_bar = MenuBar(accel_group)
        menu_bar.connect("port-selected", self.change_port_selected)
        menu_bar.show()

        toolbar = Toolbar(self)
        toolbar.connect("port-selected", self.change_port_selected)
        toolbar.connect("save-clicked", self.save_registers)
        toolbar.connect("refresh-clicked", self.update_registers)
        toolbar.connect("export-clicked", self.export_settings)
        toolbar.connect("import-clicked", self.import_settings)
        toolbar.connect("chat-clicked", self.start_chat)
        toolbar.show()

        registers_hbox = gtk.HBox(False, 3)
        registers_hbox.show()

        register_entries_vbox = gtk.VBox(False, 3)
        register_entries_vbox.set_border_width(10)
        register_entries_vbox.show()

        separator = gtk.VSeparator()
        separator.show()

        register_guis_vbox = gtk.VBox(False, 3)
        register_guis_vbox.set_border_width(10)
        register_guis_vbox.show()

        self.port_name = gtk.Label()
        self.port_name.set_alignment(0.5, 0)

        vbox = gtk.VBox(False, 0)
        vbox.show()

        vbox.pack_start(self.port_name, False, False, 10)
        vbox.pack_start(register_entries_vbox)

        for i, register_name in enumerate(Window.editable_register_names):
            register = generic.Register(register_name)
            setattr(self, register_name.lower(), register)
            register.entry.connect("focus-in-event", self.entry_selected)
            register.show()

            try:
                gui = getattr(registers, register_name)(register.entry)
            except AttributeError:
                pass
            else:
                register.set_verbose_widget(gui)
                register_guis_vbox.pack_start(gui, False, False, 3)

            register_entries_vbox.pack_start(register, False, False, 0)

        for widget in [vbox, separator, register_guis_vbox]:
            registers_hbox.pack_start(widget, False, False, 0)

        for widget in [menu_bar, toolbar, registers_hbox]:
            main_vbox.pack_start(widget, False, False, 0)

        main_vbox.show()

        self.change_port("/dev/fscc0")

        self.add(main_vbox)

    def entry_selected(self, widget, data=None):
        for register_name in Window.editable_register_names:
            getattr(self, register_name.lower()).hide_gui()

        getattr(self, widget.register_name.lower()).show_gui()

    def change_port_selected(self, widget, port_name):
        try:
            fscc.Port(port_name, 'w+b')
        except IOError as e:
            if e.errno == 13:
                dialog = dialogs.InsufficientPermissionsDialog()
            else:
                dialog = dialogs.InvalidPortDialog()

            dialog.run()
            dialog.destroy()
        else:
            self.change_port(port_name)

    def change_port(self, port_name):
        try:
            self.port = fscc.Port(port_name, 'w+b')
        except IOError:
            pass
        else:
            for register_name in Window.editable_register_names:
                value = getattr(self.port.registers, register_name)
                getattr(self, register_name.lower()).set_value(value)

            vstr = self.port.registers.VSTR

            prev = (vstr & 0x0000FF00) >> 8
            frev = vstr & 0x000000FF

            self.port_name.set_markup("<b>%s</b> (<i>%x.%02x</i>)" % (port_name, prev, frev))
            self.port_name.show()

            self.emit("port-changed", port_name)

    def save_registers(self, widget=None):
        invalid_values = []

        for i, register_name in enumerate(Window.editable_register_names):
            try:
                value = getattr(self, register_name.lower()).get_value()
            except ValueError:
                invalid_values.append((register_name, value))

        if invalid_values:
            dialog = dialogs.InvalidValuesDialog(invalid_values)
            dialog.run()
            dialog.destroy()

            return

        for register_name in Window.editable_register_names:
            value = getattr(self, register_name.lower()).get_value()
            setattr(self.port.registers, register_name, value)

        dialog = dialogs.SettingsSavedDialog()
        dialog.run()
        dialog.destroy()

    def update_registers(self, widget=None):
        for register_name in Window.editable_register_names:
            value = getattr(self.port.registers, register_name)
            getattr(self, register_name.lower()).set_value(value)

    def export_settings(self, widget, filename):
        registers = fscc.Port.Registers()

        for register_name in Window.editable_register_names:
            value = getattr(self, register_name.lower()).get_value()
            setattr(registers, register_name, value)

        export_file = open(filename, 'w')
        registers.export_to_file(export_file)
        export_file.close()

        dialog = dialogs.SettingsExportedDialog()
        dialog.run()
        dialog.destroy()

    def import_settings(self, widget, filename):
        registers = fscc.Port.Registers()

        import_file = open(filename, "r")
        registers.import_from_file(import_file)
        import_file.close()

        for register_name in Window.editable_register_names:
            value = getattr(registers, register_name)

            if value >= 0:
                getattr(self, register_name.lower()).set_value(value)

        dialog = dialogs.SettingsImportedDialog()
        dialog.run()
        dialog.destroy()

    def start_chat(self, widget, data=None):
        chat_dialog = ChatDialog(self.port)

        chat_dialog.run()
        chat_dialog.destroy()


gobject.type_register(Window)

gobject.signal_new("port-changed", Window, gobject.SIGNAL_RUN_FIRST,
                   gobject.TYPE_NONE, (gobject.TYPE_STRING,))


if __name__ == "__main__":
    fscc_window = Window()
    fscc_window.show()

    gobject.threads_init()
    gtk.main()
